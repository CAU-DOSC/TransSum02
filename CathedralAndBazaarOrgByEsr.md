# 성당과 시장

필자는 가장 중요한 소프트웨어 (운영체제나 Emacs 같이 대단히 커다란 커다란 도구들) 은 성당을 건축하듯이, 즉 몇 명의 도사 프로그래머나 작은 그룹의 뛰어난 프로그래머들에 의해 조심스럽게 만들어지고 베타버전도 필요없이 발표되어야 한다고 생각했던 것이다.

필자는 리눅스에서 고요하고 신성한 성당의 건축방식은 찾아볼 수 없었다. 대신, 리눅스 공동체는 서로다른 의견과 접근방법이 난무하는 매우 소란스러운 시장같았고 이런 시장바닥에서 조리있고 안정적인 시스템이 나온다는 것은 연속된 기적으로만 가능한 것처럼 보였다. 필자는 시장 스타일이 매우 효과적이라는 사실은 분명히 충격이었고 이를 이해하려고 애썼다.

1996년 중반에야 이해가 되기 시작했다. 필자의 이론을 시험해 볼 수 있는 완벽한 기회가 오픈소스 프로젝트의 형태로 찾아왔다. 여기에서 의식적으로 시장 스타일을 시도해 볼 수 있었고, 큰 성공을 거두었다. 이 글의 나머지 부분에서는 그 프로젝트에 대해 이야기하고 효과적인 오픈소스 개발에 대한 격언들을 제시한다.

## 메일은 배달되어야만 한다.

필자는 즉시 배달되는 인터넷 이메일에 매우 익숙해졌다. 복잡한 이유로 인해 집의 컴퓨터와 CCIL 사이에 SLIP 연결을 하기가 힘들었다. 마침내 성공하고 나자, 주기적으로 locke 에 접속해 메일이 왔는지 체크해 보는 것이 매우 귀찮은 일이라는 것을 알게 되었다. 필자는 메일이 snark 로 배달되었을 때 바로 알 수 있고, 자신의 도구들을 가지고 메일을 다룰 수 있게 되는 것을 원했다. 이 과정에서 필요한 클라이언트들 중 필자의 갈증을 해소시켜주지 못했다. 여기에서 첫 번째 교훈을 얻을 수 있다.

1. 소프트웨어의 모든 좋은 작업은 개발자의 개인 가려움증을 긁어 냄으로써 시작된다.

2. 좋은 프로그래머는 어떤 프로그램을 만들어야 할 지 안다. 위대한 프로그래머는 어떤 프로그램을 다시 만들어야 할 지 (그리고 재사용해야 할 지) 안다.

3. 한 명을 던질 계획을 세우십시오. 어쨌든, 당신은 할 것입니다. "(프레드 브룩스, 신화 인 달, 11 장)

다른 말로 하자면, 첫 번째 해결책을 구현할 때까지도 진짜 문제가 무엇인지 이해하지 못하는 경우가 종종 있다는 것이다. 두 번째가 되어서야 어떻게 하는 것이 옳은 것인지 충분히 알게 될 수 있다. 따라서 만일 올바른 방법을 찾고 싶다면 최소한 한 번은 처음부터 다시 시작할 준비를 해 두어야 한다.

4. 적절한 태도를 가지고 있으면 흥미로운 문제가 당신을 찾아갈 것이다.

5. 프로그램에 흥미를 잃었다면 프로그램에 대한 당신의 마지막 의무는 능력있는 후임자에게 프로그램을 넘겨주는 것이다.

## 사용자가 있다는 것의 중요성

사용자들이 있다는 것은 매우 좋은 일이다. 당신이 누군가의 필요를 충족시켜주고 있으며 일을 잘 해나가고 있다는 것을 보여주기 때문만은 아니다. 적절하게 유도해 준다면 사용자들을 공동개발자가 될 수 있다.

6. 사용자를 공동 개발자로 취급하는 것은 신속한 코드의 개선과 효과적인 디버깅을위한 가장 간단하고 쉬운 방법이다.

이 효과의 위력은 과소평가되기 쉽다. 사실, 오픈소스의 세계의 우리들조차 시스템의 복잡도에 대항하여 많은 수의 사용자가 얼마나 힘이 되는지를 리누스 토발즈가 보여주기 전까지 과소평가하고 있었다. 

 리누스의 가장 중요한 해킹은 리눅스 개발모델을 만든 것이라고 생각한다. 리눅스의 성공과 방법론에 대한 선례는 GNU Emacs Lisp 라이브러리와 Lisp 코드 아카이브에서 찾아볼 수 있다. Lisp 코드 풀의 진화는 유동적이었고, 사용자가 주도한 것이었다. 아이디어와 프로토타입 모드들은 안정적인 최종형태를 갖추기까지 종종 3~4번씩 다시 쓰여졌다. 느슨하게 묶인 공동작업이 인터넷으로 인해 가능해 졌고, 리눅스 에서처럼 매우 자주 일어나는 일이 되었다.

## 일찍, 그리고 자주 발표하라

7. 일찍 배포하고 자주 배포하라. 그리고 사용자들에게 귀를 기울여라.

초기에 리누스는 하루에 한 번 이상 새로운 커널을 발표하기까지 했다. 리누스가 공동개발자들 이라는 자신의 기반을 잘 만들었고, 인터넷이라는 지렛대를 이용하여 누구보다도 열심히 협동작업에 몰두했기 때문에 이런 방식은 성공했다.

리누스는 그의 해커/사용자들에게 지속적인 자극과 보답을 제공했다 -- 리눅스 개발에 참여함으로써 자기만족을 얻으리라는 전망에 자극 받았고, 그들이 하는 일이 계속해서 (어떤 때는 날마다) 향상되고 있다는 것이 보답이 되었다. 

8. 충분히 많은 베타테스터와 공동개발자가 있으면 거의 모든 문제들은 빨리 파악될 것이고 쉽게 고치는 사람이 있게 마련이다. 

덜 형식적으로 말하자면, '보고 있는 눈이 충분히 많으면 찾지 못할 버그는 없다.' 는 이것을 '리누스의 법칙' 이라고 부른다.

리누스는 문제를 이해하고 고치는 사람이 그 문제를 처음 파악한 사람과 항상 같은 것이 아니라 오히려 다른 경우가 더 많다고 이의를 제기했다 가장 중요한 점은 사람이 충분히 많을 경우 이 두 가지가 모두 매우 빨리 일어나는 경향이 있다는 것이다.

여기에 성당 건축과 시장 스타일의 핵심적인 차이점이 있다. 프로그래밍의 성당 건축방식 관점에서 보자면 버그와 개발 문제는 어렵고, 까다로우며 심오한 현상이다. 문제를 해결하려면 소수의 사람이 정밀한 검사를 수행해야 모두 끝났다는 확신을 가질 수 있다. 따라서 발표 사이의 기간이 길어지고, 오랫동안 기다린 릴리즈가 완벽하지 않을 때는 실망이 따른다. 반면, 시장의 관점에서는 최소한 새로운 릴리즈가 나올 때마다 그것과 씨름하는 수천의 열정적인 공동개발자들에게 알려진다면 금방 쉽게 해결할 수 있는 문제로 바뀐다. 따라서 더 많이 교정을 받고 싶다면 자주 발표해야 하며 덤으로 서투른 부분이 드러나더라도 잃을 것이 적다는 이점이 있다. 각 사람들이 버그를 찾아낼 때 조금씩 다른 개념의 집합과 분석 도구들을 사용하여 문제의 다른 각도에서 접근하기 때문이다. 

따라서 더 많은 베타테스터를 가지는 것은 개발자의 관점에서 현재의 '가장 심오한' 버그의 복잡성을 줄여주지는 않을 테지만, 누군가의 도구가 문제에 딱 들어맞아 그 버그가 그 사람에게는 쉽게 잡을 수 있는 것이 될 가능성을 높여준다.

## 얼마나 많은 눈이 복잡성를 다스리는가

시장 스타일이 디버깅과 코드 개발을 매우 가속화 한다는 것은 전체적으로 지켜봐야 할 점이다.

이해해야 할 한가지 중요한 점은 왜 소스에 대해서 모르는 사용자들이 보내는 버그 리포트가 유용하지 않다고 여겨지는지 파악하는 것이다. 소스를 모르는 사용자들은 증상의 표면만을 알려준다; 그들은 그들의 환경을 당연한 것으로 여기기 때문에 (a) 중요한 배경 데이터를 생략하고 (b) 좀처럼 버그를 재현하기 위한 믿을 만한 방안을 알려주지 않는다.

오픈소스 개발은 이 고리를 부수어 테스터와 개발자가 실제 소스코드를 기반으로 한 공유된 표현을 개발할 수 있도록 하고, 그것에 대해 효과적으로 소통할 수 있도록 하였다. 사실상, 외부에서 볼 수 있는 증상만 보고하는 버그 리포트의 종류와 개발자의 정신적 표현 프로그램에 직접 연결되는 종류 사이에는 개발자에 대한 영향력에 큰 차이가 있다.

이런 효과는 서로 다른 표면적인 증상들을 따라가 버그까지 가는 길이 증상을 보는 것 만으로 예측되지 않을 만큼 복잡할 경우에 더욱 증폭될 것이다. 이러한 경로를 순차적으로 추출하는 한 명의 개발자는 첫번째 시도에서 어려운 경로를 쉬운 경로라 생각하고 고를 가능성이 있다. 하지만 많은 사람이 빠른 배포를 하면서 경로를 병렬적으로 찾는다고 해보자. 그럼 그중 한 명이 가장 쉬운 경로를 찾을 것이고, 더 짧은 시간 안에 버그를 고칠 것이다. 프로젝트 지지자는 그것을 보고 새로운 릴리즈를 할 것이고 같은 버그를 고치던 다른 사람들은 더 어려운 방법을 시도해 보기 전에 멈출 수 있다.

## 언제 장미는 장미가 아니게 되는가?

Linus의 행동을 연구하고 왜 성공했는지에 대한 이론을 세우면서, 필자는 이 이론을 나의 새로운 프로젝트에 시험하기로 결정했다. 
그러나 내가 첫번째로 한일을 popclient를 재구성하고 단순화하는 것 이었다. carl Harris의 구현은 좋았지만, 많은 C 프로그래머들에게 불필요하게 복잡했다. 그는 코드를 중앙으로 다루고 자료구조를 코드를 지원하는 용도로 다루었다. 결과적으로 코드는 아름다웠지만 자료구조 설계는 오히려 못 생겼다. 
필자는 코드 및 자료구조 설계를 개선하는 것 외에도 재작성에 다른 목적이 있었다. 그 목적은 내가 완벽히 이해하는 것으로 진화 시키는 것이다. 
내가 처음으로 변화시킨 것은 IMAP support를 추가 시키는 것 이였다. 이것과 이전의 변화는 특히 C언어에서 다이나믹 작성을 피해야 한다는 원칙에 따른 것이다.

9. 좋은 자료구조와 안 좋은 코드는 다른 방법보다 좋게 수행된다.

Brooks, Chapter 9:”순서도를 보여주고 표를 감추면 나는 표를 모르지만, 표를 보여주고 순서도를 감추면 나는 당신의 순서도가 필요 없다. ”
이 원칙을 따르면서 이름을 정리했다. Popclient가 어떻게 fetched mail을 SMTP port에 전달하는지 배우는 변화를 하기전에 필자는 이전에 Linus가 했던 방법에 대한 내 이론대로 프로젝트를 테스트했다. 자주 일찍 발표하고 사람들에게 beta lsit를 전송하고 beta 테스터들의 투표를 반영했다. 결과적으로 많은 버그 리포트와 좋은 해결법을 알게 됐다. 

10. beta 테스터를 가장 중요한 자원인 것처럼 대하면, 그들은 가장 중요한 자원을 줄 것이다.


## Popclient가 Fetchmail이 되다.

이 프로젝트의 진정한 전환점은 Harry Hochheiser가 클라이언트 컴퓨터의 SMTP 포트로 메일을 전달하는 스크래치 코드를 보냈을 때였다. 필자는 이 기능의 구현이 다른 모든 메일 전송모드가 필요 없다는 것을 알았다. SMTP 포워딩 개념은 Linus의 방법을 모방하여 얻은 가장 큰 결과이다.

11. 좋은 아이디어를 얻는데 있어서 가장 좋은 방법은 사용자로부터 좋은 아이디어를 인식하는 것이다. 

프로젝트를 시작한지 불과 몇 주 후에, 사용자로부터 많은 이메일을 받게 되었다. 그러나 모든 공통적인 설계에 두가지 더 근본적이고 비 정치적인 교훈이 있다.

12. 좋은 해결법은 문제에 대한 개념이 잘못되었다는 것을 깨닫는 데 있다.

필자는 MTA/MDA로서 popclient를 계속 개발함으로써 잘못된 문제를 해결하려고 노력했다. 개발 중 벽에 부딪혔을 때 문제는 재구성 되어야한다. 문제를 재구성하여 1. SMTP 포워딩 지원을 일반 드라이버로 해킹 2.기본 모드를 만들고 3. 모든 출력 옵션을 구성 하는 것으로 해결했다. 그 결과 모든 문제가 사라졌다. 나중에 동적 SLIP과 관련된 모호한 상황을 사용자 지정 로컬 MDA를 통해 전달하는 것보다 간단한 방법을 찾았다. 기능을 잃지 않는다면 노후한 방법을 버리는데 주저하지 마라. Antoine는 다음과 같이 말했다.

13. “설계에서 완벽함은 추가 할 것이 없을 때가 아니라, 더 이상 버릴 것이 없을 때 이루어진다.”

 코드가 더 쉽고 간단해 질 때가 좋은 것이다. 이 과정에서 프로젝트는 popclient와 다른 정체성을 획득했고 이름을 fetchmail이라 바꾸었다. SMTP에서 fetchmail로 개발되는 과정에서 일반적인 교훈이 있다. 병렬화 가능한 디버깅, 개발, 설계 공간 탐색이다. 덕분에 누락버그의 수정이 가능하다. 높은 설계 수준이라도 많은 공동 개발자가 설계 공간을 탐색하는 것은 매우 중요하다. 확장에 의한 탐색 덕분에 나와 Harry도 큰 승리를 거두었다.


## Fetchmail의 성장

당신은 나중에 결과가 필연적이고, 자연스럽고, 오히려 미리 정해진 것처럼 보일만큼 강력한 설계 아이디어로 그것에 빠져들어야 한다. 이와 같은 아이디어를 위해 노력할 수 있는 방법은 오직 수많은 아이디어를 가지고 있거나, 다른 사람들의 좋은 아이디어들을 창작자가 가야한다고 생각하는 방향으로 이끌 만큼의 공학적 정의를 가지고 있는 것 밖에 없다.
필자는 칼 해리스와 해리 호크헤이서로부터 몇가지 아이디어를 얻었고 그것들을 열심히 발전시켰다. 우리 중 아무도 사람들이 천재적이라고 생각하는 낭만적인 방식으로 '독창적' 이지 못했다. 내가 이를 깨닫고 난 후에 쓰는 가장 첫번째이고 압도적으로 중요한 기능은 멀티드롭 서포트이다(multidrop support). 멀티드롭 서포트 기능을 추가하게 된 주된 이유는 이 기능이 나로 하여금 모든 경우에 대하여 주소 지정을 다루도록 하여, 싱글 드롭으로부터 버그를 해결할 수 있다고 생각하게 했기 때문이다.
다음은 멀티드롭 주소지정이 아주 뛰어난 설계 방안임을 밝혀준다:

14. 어떠한 도구도 예측가능한 방식으로나 절대 예측할 수 없는 방식으로나, 모두 유용해야 한다.

나의 베타 테스터에 의해 요구된 또다른 중요한 변화는 8비트 짜리의 MIME 연산을 지원하는 것이었다. 이 기능을 개발한 이유는 다음 규칙에 따른 것이다:

15. 어떤 종류의 게이트웨이 기반 소프트웨어를 설계할 때는, 데이터 스트림을 최대한 방해하지 않도록 노력하는 것이다!

## Fetchmail로부터 몇가지 배울 점들

인출 메일 제어 문법의 언어 영역은 매우 제한되어 있기 때문에, 영어의 매우 작은 일부와 실제 제어 언어 사이에 정신적으로 이동하는 것의 혼란은 매우 적은 가능성이 있다. 이러한 것에 배울 점이 있다;

16. 당신의 언어가 Turing-complete 가까이에 없다면, 문법적 설탕은 당신의 친구가 될 것이다.

또다른 배울 점은 모호함에 의한 보안에 관한 것이다.

17. 보안 시스템은 자신의 비밀만큼이나 안전하다. 가짜 비밀을 조심하라.

## 시장(Bazaar) 스타일을 위한 필요한 전제조건

당신이 커뮤니티를 제작하기 시작했을 때, 당신이 제시할 수 있는 것은 '타당한 약속' 이다. 이는 (a) 프로그램이 잘은 아니더라도 돌아가는 것, 그리고 (b) 가능성이 있는 공동 개발자들에게 이것이 예측가능한 미래에 분명히 형태를 잘 갖춘 것으로 발전 할 수 있다고 설득하는 것이다.

필자는 조정자가 다른 사람으로부터 좋은 설계 아이디어를 인지할 줄 아는 능력은 매우 중요하다고 생각한다. 리눅스와 인출 메일 프로젝트 모두 이러한 증거를 보여주고 있다. 예를 들어, 필자는 내가 명석해 지려는 나의 경향을 억제했기 때문에, 인출 메일이 부분적으로 성공했다고 믿는다.

시장 프로젝트에 있어서 뛰어난 설계 능력만큼이나 중요한 기술이라고 생각되는 것은 시장 프로젝트의 조정자나 리더가 반드시 좋은 사람들과 의사소통 능력을 가지고 있어야 한다는 것이다.

## 오픈소스 소프트웨어에 대한 사회적 문맥

18. 흥미로운 문제를 해결하기 위해서는, 당신이 흥미를 느끼는 문제부터 찾아보기 시작하라

리눅스와 인출 메일의 역사가 우리로 하여금 집중하게 끔 하는 점은 사용자와 공동 개발자의 크고 활발한 커뮤니티의 존재 안에서의 소프트웨어의 발전이다.
"객관화 프로그래밍(egoless programming)"에 대한 제롤드 웨인버그의 주장에 따르면, 그는, 개발자들이 그들의 코드에 대해 텃세를 부리지 않고, 다른 사람들로 하여금 그 안에 있는 버그와 가능성 있는 향상을 보도록 격려하는 직장에서 프로그램 향상이 다른 어떤 곳에서 보다 매우 빠르게 나타난다고 주장한다.
코딩은 본질적으로는 개인의 활동이지만 가장 중요한 핵심은 전체 커뮤니티의 지력과 주의와 관련된 것이다. 

혼자서만 개발하는 개발자는 수백명으로부터 여러 피드백을 얻는 개발자들에비해 뒤떨어지게 될것이다.
하지만 과거의 유닉스 세계에서는 다양한 라이센스, 거래 비밀, 상업적 관심과 충분히 발전을 이루지 못한 인터넷에 의해 이러한 방식을 금지해왔엇다.
저렴한 인터넷이 발전되기 전, 웨인버그의 "이글루" 프로그래밍이라는 문화를 장려하는 지리적으로 가까운 공동체들이 있었다.
리눅스는 전 세계와 그 인재들을 사용한 성공적인 첫번째 프로젝트였다.
리눅스의 발전이 World Wide Web, ISP의 발전들과 같은 기간에 일어난것은 결코 우연이아니다.
이에 있어서 리눅스 토발즈는 인터넷 액세스가 퍼짐에 따라 만들어진 새로운 규칙에 따라 작업하는 방법을 배운 최초의 사용자였다.
필자는 값싼 인터넷이 리눅스 모델의 발전에 필요조건이기는 하지만 충분조건은 아니라고 생각한다. 

또 다른 중요한 요소는 개발자들이 공동개발에 이끌리고 매체들로부터 최대한의 수단을 이끌어 낼 수 있는 리더쉽과 협력적인 풍습이다.
필자는 이 리더쉽이 권력 관계이 기초할 수 없고, 그러할 수 있을지라도 강압에 의한 리더쉽은 현재의 결과를 이끌어낼 수 없을것이라고 주장한다.
웨인버그는 이 리더쉽에 대하여 한 러시아 인의 과거 기억을 인용하였다. 
그 러시아 인은 자라온 환경 때문에 자신과 같은 모든 젊은이들이 강압적인 리더쉽이 필요하다는 생각을 갖고 있었다.
하지만 기업을 경영하며 여러 사람들을 상대하며 작은 실수가 즉시 큰 결과를 가져올 수 있다는것을 보게되어 명령과 명령의 원칙에 따라 행동하는것 사이의 차이점을 인식하기 시작하였다.
전자는 군대에서나 실용적이지만 현실 세계에서는 아무런 가치가 없었다. 또한 그 목적은 많은 단합된 의지의 가혹한 노력을 통해서만 달성될 수 있다.
이 많은 단합된 의지의 가혹한 노력이 정확히 리눅스 프로젝트가 요구하는것이다. 또한 명령의 원리는 무정부주의자들의 낙원이라 불리는 인터넷상의 지원가들에게는 불가능하다.

합동 프로젝트를 이끌고 싶은 해커들이 효과적으로 작업하기 위해서는 크로포트킨의 방식과 리눅스 토발즈의 법칙을 배워야 한다고 주장한다.
앞서 필자가 리눅스 토발즈의 법칙에 대한 설명으로 델포이 효과를 언급하였지만 자유시장, 생태학이 리눅스 세계에 더 유사하다. 
리눅스 토발즈는 대부분이 다른이들에 의해 개발되는 프로젝트들의 문지기로써 성공적으로 자리를 매김하였으며 프로젝트가 자생력을 지닐때 까지 프로젝트에 대한 관심을 키움으로써 크로포트 원리를 보였다.
우리는 리눅스 토발즈의 방법이 개인 개발자들이 가능한한 끝까지 확고하게 연결할수 있는 효과적인 시장을 만드는것이라고 볼 수 있다.

fetchmail 프로젝트에서 필자는 그의 방법이 좋은 결과를 이끌어 냈다는것을 증명해냈다. 
많은 사람들이 자기 주도적인 이기주의자들이 하락하기를 바라지만 리눅스 documentation에 명백히 왜곡된다.
fetchmail,리눅스 커널 프로젝트들은 많은 해커들의 노력에 적절히 보상함으로써 프로젝트의 붕괴없이 많은 개발자, 종합자들이 코드를 캡쳐하기위해 인터넷을 사용할 수 있다는것을 증명하였다. 

19. 개발 담당자가 최소한 인터넷에 버금가는 의사 소통 수단을 보유하고 있으며 강압없이 어떻게 이끌어가는지를 안다면 많은 사람들이 모일수록 나을것이다.

오픈소스의 미래는 리눅스게임을 할줄 아는 사람들, cathedrl and embrace the bazzar와 연관된 사람들에 달려있다. 
이는 개인의 비젼이 더 이상 중요하지 않다는것이 아니라 오픈 소스 소프트웨어가 개인으로부터 시작되어 이에 흥미를 지닌 여러 사람들들로 확장됨으로써 이루어진다는것이다.
이는 오픈 소스 소프트웨어만의 문제가 아니다. 그 어떠한 폐쇄된 소스 개발자도 한 문제를 해결하기 위하여 리눅스 커뮤니티가 지닌 인재 풀을 따라잡을 수 없게될것이다.
아마 결국에는 오픈소스 문화가 승리하게 될것이다. 협력이 도덕적으로 옳다는것이 아니라 간단히 폐쇄된 소스 세계는 어떤 문데에 대하여 더 많은 숙련된 시간을 투입할 수 있는 오픈 소스 
공동체들과의 경쟁에 있어서 이길 수 없기 때문이다. 

